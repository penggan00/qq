require('dotenv').config();
const { Telegraf } = require('telegraf');
const tencentcloud = require("tencentcloud-sdk-nodejs");

// ç¯å¢ƒå˜é‡æ ¡éªŒ
['TELEGRAM_API_KEY', 'TENCENT_SECRET_ID', 'TENCENT_SECRET_KEY', 'TELEGRAM_CHAT_ID'].forEach(varName => {
  if (!process.env[varName]) {
    console.error(`ç¼ºå°‘å¿…è¦ç¯å¢ƒå˜é‡: ${varName}`);
    process.exit(1);
  }
});

// åˆå§‹åŒ–è…¾è®¯äº‘å®¢æˆ·ç«¯
const tmtClient = new tencentcloud.tmt.v20180321.Client({
  credential: {
    secretId: process.env.TENCENT_SECRET_ID,
    secretKey: process.env.TENCENT_SECRET_KEY,
  },
  region: "ap-na-siliconvalley",
  profile: {
    httpProfile: { reqTimeout: 30 }
  }
});

// åˆå§‹åŒ– Telegram æœºå™¨äºº
const bot = new Telegraf(process.env.TELEGRAM_API_KEY);

// å·¥å…·å‡½æ•°ï¼šæ™ºèƒ½åˆ†å‰²æ¶ˆæ¯
function splitMessage(text) {
  const MAX_LENGTH = 4096;
  const splitPoints = [
    { regex: /\n{2,}/g, weight: 3 },  // æ®µè½åˆ†éš”
    { regex: /[ã€‚ï¼ï¼Ÿ]/g, weight: 2 }, // å¥å­ç»“æŸ
    { regex: /[ï¼Œï¼›]/g, weight: 1 }    // å¥å­ä¸­é—´
  ];

  let remaining = text;
  const chunks = [];

  while (remaining.length > 0) {
    let splitIndex = -1;
    let maxWeight = 0;

    // åŠ¨æ€å¯»æ‰¾æœ€ä½³åˆ†å‰²ç‚¹
    for (const { regex, weight } of splitPoints) {
      const matches = [...remaining.matchAll(regex)];
      for (const match of matches) {
        if (match.index < MAX_LENGTH && weight > maxWeight) {
          splitIndex = match.index + match[0].length;
          maxWeight = weight;
        }
      }
    }

    const chunk = splitIndex > 0 
      ? remaining.substring(0, splitIndex)
      : remaining.substring(0, MAX_LENGTH);

    chunks.push(chunk.trim());
    remaining = remaining.substring(chunk.length).trim();
  }

  return chunks;
}

// å·¥å…·å‡½æ•°ï¼šè¾“å…¥æ¶ˆæ¯’
function sanitizeInput(text) {
  return text
    .replace(/<[^>]*>?/gm, '') // ç§»é™¤HTMLæ ‡ç­¾
    .replace(/[^\p{L}\p{N}\p{P}\s]/gu, '') // è¿‡æ»¤éå¸¸è§„å­—ç¬¦
    .substring(0, 20000); // é•¿åº¦é™åˆ¶
}

// å·¥å…·å‡½æ•°ï¼šè¯­è¨€æ£€æµ‹
async function detectLanguage(text) {
  try {
    const { Lang } = await tmtClient.LanguageDetect({ 
      Text: text,
      ProjectId: 1323297
    });
    return Lang.toLowerCase();
  } catch (error) {
    console.error('Language detection failed:', error);
    return 'auto';
  }
}

// å·¥å…·å‡½æ•°ï¼šç¿»è¯‘æ–‡æœ¬
async function translateText(text, source, target) {
  const params = {
    SourceText: text,
    Source: source,
    Target: target,
    ProjectId: 1323297
  };

  try {
    const { TargetText } = await tmtClient.TextTranslate(params);
    return TargetText;
  } catch (error) {
    console.error('Translation failed:', error);
    throw new Error(`ç¿»è¯‘å¤±è´¥: ${error.message}`);
  }
}

// å¤„ç† Telegram æ¶ˆæ¯
bot.on('text', async (ctx) => {
  try {
    // æƒé™éªŒè¯
    if (ctx.message.from.id !== parseInt(process.env.TELEGRAM_CHAT_ID)) {
      return ctx.reply('â›” æœªç»æˆæƒçš„è®¿é—®');
    }

    // å‘é€è¿›åº¦æç¤º
    const { message_id: messageId } = await ctx.reply('ğŸ”„ æ­£åœ¨åˆ†ææ–‡æœ¬...');

    // è¾“å…¥æ¶ˆæ¯’
    const sanitizedText = sanitizeInput(ctx.message.text);

    // è¯­è¨€æ£€æµ‹
    const sourceLang = await detectLanguage(sanitizedText);
    const targetLang = sourceLang === 'zh' ? 'en' : 'zh';

    // æ‰§è¡Œç¿»è¯‘
    const translatedText = await translateText(sanitizedText, sourceLang, targetLang);

    // åˆ†å—å‘é€ç»“æœ
    const chunks = splitMessage(translatedText);
    await ctx.telegram.editMessageText(
      ctx.chat.id,
      messageId,
      null,
      "âœ… ç¿»è¯‘å®Œæˆï¼š"
    );

    for (const chunk of chunks) {
      await ctx.reply(chunk);
    }
  } catch (error) {
    console.error('å¤„ç†é”™è¯¯:', error);
    await ctx.reply(`âŒ é”™è¯¯ï¼š${error.message}`);
  }
});

// å¯åŠ¨æœºå™¨äºº
bot.launch().then(() => {
  console.log('æœºå™¨äººå·²å¯åŠ¨');
}).catch(error => {
  console.error('å¯åŠ¨å¤±è´¥:', error);
});

// é”™è¯¯å¤„ç†
process.on('uncaughtException', error => {
  console.error('æœªæ•è·å¼‚å¸¸:', error);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('æœªå¤„ç†çš„ Promise æ‹’ç»:', promise, 'åŸå› :', reason);
});